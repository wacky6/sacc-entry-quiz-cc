SACC Entry Quiz, Answer & Tips
===

##### 0. (C) 签到题 
首先，不可能是D。屈大大不戴墨镜，不可能是B。屈大大萌萌哒，不可能是A的怪蜀黍。所以只能选C。
另一个思路，屈大大说过：人生苦短，我用python。C中的汉子穿了这件衣服，所以多半是屈大大。

##### 1. (A) 字符串概念
首先你要知道C中的逃逸字(Escape-sequence)，`\0`表示`(byte)0`。
如果你知道C字符串的正式英文名，这个题目应该很简单。用`char[]`、`const char*`来表示字符串，学名：`Null-terminated byte strings`。翻译成中文：**以NULL(0)表示结束的一串字符**。

换句话说，C中的字符串 = 一串非0字符，这串字符后跟着一个0。

`Null-terminated string`是一个非常重要的概念！在涉及字符串操作的时候，使用`Null-terminated`的特性可以简化代码实现。（比如切分单词，对输入串进行一次扫描，将分隔符置为'\0'，记录下非0开头字符，这些非0开头字符组成的数组就是输入串中的单词）这样你也就可以理解为什么C中`strchr`等函数返回的是`char*`（表示字符的指针，直接说明了字符的内存位置），而不像Pascal一样返回`unsigned long`（第几个字符）

注意，`Null-terminated`在某些情况下会引入BUG或漏洞。比如早年间php的`%00`截断（有兴趣可自行谷歌/度娘）。严格的情况下，一串字符的长度应该由一个变量单独记录，而不应该通过串尾的`\0`。

对于这道题目，`char str[] = "abc\0"`等价于`char str[] = {'a', 'b', 'c', '\0', '\0'}`，`strlen`获取字符串长度：从输入指针位置开始向后扫描，直到发现`'\0'`。所以`strlen(str)`为3。

`'\0'`和`0`在数值上等价，但语义不同。前者用来表示字符串的终结符，后者表示数值0。
`'0'`表示字符0，数值不同于`'\0'`和`0`。

##### 2. (C) if语句、赋值语句vs比较相等、短路求值
注意`if`中写的是`n=2`而不是`n==2`，前者是**赋值操作**（给n赋值，并返回赋之后n的值），后者**比较两个值是否相等**（返回n是否等于2）。

短路求值：对于`&&`（逻辑与）、`||`（逻辑或），当左侧操作数能够确定表达式的值时，右侧操作数不会被求值。（比如：`true || strlen("abc")`，左侧为`true`，已经能够确定表达式的值为真，所以右侧不会被求值：`strlen`不会执行）。

对于这道题来说，`||`的左操作数 `(n=2)`，把2赋值给n，并将2作为`(n=2)`的值；在C语言中，非0为`true`，表达式的值已确定。所以，右侧访问非法指针的操作不会执行。
if判断条件为true，所以输出为`hello world!`

##### 3. (C) 后置自增，静态变量
`a++`：返回a的值，a自增1
`++a`：a自增1，返回a的值
(++在{前/后}，就{先/后}自增）

静态变量在声明时完成初始化，初始化语句只会执行一次。

##### 4. (F) 内存的概念，小端存储(Little-Endianness)，前置自增
short为2字节，char为1字节。
array在内存中看起来像这样：
`Offset +n`标示内存位置偏移量，`Memory`表示改内存位置的值（16进制）。`char`表示以`char`为单位计算的偏移量，`short`表示以`short`为单位计算的偏移量。

```Text
Offset |+0 |+1 |+2 |+3 |+4 |+5 | ...
Memory | 23| 01| 67| 45| ab| 89| ...
char   | 0 | 1 | 2 | 3 | 4 | 5 | ...
short  |   0   |   1   |   2   | ...
```

小端存储：（比如，x86下）对多子节整数，位权低(Least Significant Byte)的字节在内存低地址。
对应的，大端存储，位权高(Most Significant Byte)的字节在内存低地址。

这里，位权低/高可以这样理解：如果一个字节发生变化，对这个整数数值影响的大小。位权高的子节变化后，整数数值变化大，位权低的字节变化后，整数数值变化不大。

对题目而言，即使不知道小端存储，用排除法：
ptr[3]为char型，所以输出的16进制数不可能为AB，CD的char偏移量为5。

[Wiki: Endianness](https://en.wikipedia.org/wiki/Endianness)

##### 5. (D) 规范！
参考C标准: [Main function](http://en.cppreference.com/w/c/language/main_function)

##### 6. (B) 操作数类型决定返回值类型
`3/2`为整数除法，返回值为整数`1`
`3/2.0`为整数除浮点数，两者均转换为浮点数，再进行除法，返回值为浮点数`1.5`
(参见7，Implicit conversion）

##### 7. (D) 类型提升 (Arithmetic Type Promotion)，补码表示/溢出
执行算术运算时，先对操作数进行类型提升，然后再运算，最后将结果裁剪(Truncate)到目标类型。
`a++`：`a=a+1`，提升a到`int`，计算结果为`32768`，然后按照short裁剪，结果为`-32768`
`b+1`：提升b到`int`，计算结果为`32768`，作为printf参数。
[Implicit conversion](http://en.cppreference.com/w/c/language/conversion)

##### 8. (B) 二维数组到内存
多维数组在内存中还是一维的。
[Array](http://en.cppreference.com/w/c/language/array)

##### 9. (B) 修饰符作用于紧跟着它的变量/类型
C可以通过编译，但在运行时报错。按照标准，修改用`"abc"`定义的字符串的字面值，会发生未定义行为（什么都可能发生），通常是内存访问出错。因为这类字面值一般存储在只读区域。

[String literals](http://en.cppreference.com/w/c/language/string_literal)

##### a. (D) 英语不好当什么码农
可移植代码：使用sizeof，不要使用固定值。
按照C标准，int至少16位。意味着：某些平台上(x86)，int为32位；另一些平台上(avr)，int只有16位。

##### b. (A) 递归梗
递归：一个东西调用自身
递推/迭代：已知当前状态，计算出下一状态。如此重复，直到达到需要的状态
CD纯粹是凑答案

##### c. (C) 玩具对给定激励总会给出确定的响应。
毕竟，玩具的本质是数字电路。妹子的本质是充满化学成分的大脑。

##### d. (C) 养成良好的编程习惯！
这个跟你合作的人很可能就是6个月后的你自己！


##### f. 
参考答案：见`src/ip-network.c`

```C
#define u32 (uint32_t)
#define u8  (uint8_t)
u32 ip4 = 0xffffffff;
u8 prefix = 24;
u8* seg = (u8*)&ip4;
scanf("%hhu.%hhu.%hhu.%hhu/%hhu", seg+3, seg+2, seg+1, seg+0, &prefix);
for (int bit = 0; bit!=32-prefix; ++bit)
	ip4 = ip4 & ~(1<<bit);	
printf("%hhu.%hhu.%hhu.%hhu\n", seg[3], seg[2], seg[1], seg[0]);
```

得分点：

* `uint32_t`, `uint8_t`（无符号数）作为类型
> 有符号数不得分；`unsigned int`**不得分**；
> `unsigned long`, `unsigned char`**一半分**
 
* 位操作
> 与参考答案不同，但功能相同均**得分**
> 只考虑prefix为8的整数倍，**不得分**
> 使用`for`/`while`，**得分**
> 使用`do-while`，**不得分**
 
* 转换为32位无符号数操作
> 直接操作4个8位无符号数，**不得分**

* 使用指针和`%hhu`直接读取到`uint32_t`
> 没有使用`uint8_t[]`，**得分**
> 使用`uint8_t[]`，**一半分**

* `scanf`格式串使用
> 只用一条scanf读取cidr地址，**得分**
> 多条`scanf`语句或使用循环，**一半分**

* 变量命名符合C语言习惯（小写字母，用`_`连接单词）
> 出现拼音/中文变量名，**不得分，再扣分**
> 全部使用拼音/中文变量名，**整题0分**
> 大小写混乱、驼峰、匈牙利命名，**不得分**

* 缩进、书写
> 不使用需缩进结构、缩进整齐，**得分**
> 缩进混乱，**整题0分**
> `scanf`, `printf`的格式串和参数可以分两行写
> *A类型变量* 和 *A类型指针* 可以写在同一行。(如`A a=0, *p=&a;`)


